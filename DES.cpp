#include "DES.h"
#include <cstring>



const uint8_t DES::ip[64] =
{
	58,50,42,34,26,18,10, 2,
	60,52,44,36,28,20,12, 4,
	62,54,46,38,30,22,14, 6,
	64,56,48,40,32,24,16, 8,
	57,49,41,33,25,17, 9, 1,
	59,51,43,35,27,19,11, 3,
	61,53,45,37,29,21,13, 5,
	63,55,47,39,31,23,15, 7
};
const uint8_t DES::fp[64] =
{
	40, 8,48,16,56,24,64,32,
	39, 7,47,15,55,23,63,31,
	38, 6,46,14,54,22,62,30,
	37, 5,45,13,53,21,61,29,
	36, 4,44,12,52,20,60,28,
	35, 3,43,11,51,19,59,27,
	34, 2,42,10,50,18,58,26,
	33, 1,41, 9,49,17,57,25
};

const uint32_t DES::pc_by_bit[64] =
{
	0x80000000L,0x40000000L,0x20000000L,0x10000000L,
	0x08000000L,0x04000000L,0x02000000L,0x01000000L,
	0x00800000L,0x00400000L,0x00200000L,0x00100000L,
	0x00080000L,0x00040000L,0x00020000L,0x00010000L,
	0x00008000L,0x00004000L,0x00002000L,0x00001000L,
	0x00000800L,0x00000400L,0x00000200L,0x00000100L,
	0x00000080L,0x00000040L,0x00000020L,0x00000010L,
	0x00000008L,0x00000004L,0x00000002L,0x00000001L,
	0x80000000L,0x40000000L,0x20000000L,0x10000000L,
	0x08000000L,0x04000000L,0x02000000L,0x01000000L,
	0x00800000L,0x00400000L,0x00200000L,0x00100000L,
	0x00080000L,0x00040000L,0x00020000L,0x00010000L,
	0x00008000L,0x00004000L,0x00002000L,0x00001000L,
	0x00000800L,0x00000400L,0x00000200L,0x00000100L,
	0x00000080L,0x00000040L,0x00000020L,0x00000010L,
	0x00000008L,0x00000004L,0x00000002L,0x00000001L
};
const uint8_t DES::des_P[32] =
{
	16,7,20,21,
	29,12,28,17,
	1,15,23,26,
	5,18,31,10,
	2,8,24,14,
	32,27,3,9,
	19,13,30,6,
	22,11,4,25
};
const uint8_t DES::des_E[48] =
{
	32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,12,13,
	12,13,14,15,16,17,16,17,18,19,20,21,
	20,21,22,23,24,25,24,25,26,27,28,29,
	28,29,30,31,32,1
};
const uint8_t DES::des_S[8][64] = {
{
	0xe,0x0,0x4,0xf,0xd,0x7,0x1,0x4,0x2,0xe,0xf,0x2,0xb,
	0xd,0x8,0x1,0x3,0xa,0xa,0x6,0x6,0xc,0xc,0xb,0x5,0x9,
	0x9,0x5,0x0,0x3,0x7,0x8,0x4,0xf,0x1,0xc,0xe,0x8,0x8,
	0x2,0xd,0x4,0x6,0x9,0x2,0x1,0xb,0x7,0xf,0x5,0xc,0xb,
	0x9,0x3,0x7,0xe,0x3,0xa,0xa,0x0,0x5,0x6,0x0,0xd
},
{
	0xf,0x3,0x1,0xd,0x8,0x4,0xe,0x7,0x6,0xf,0xb,0x2,0x3,
	0x8,0x4,0xf,0x9,0xc,0x7,0x0,0x2,0x1,0xd,0xa,0xc,0x6,
	0x0,0x9,0x5,0xb,0xa,0x5,0x0,0xd,0xe,0x8,0x7,0xa,0xb,
	0x1,0xa,0x3,0x4,0xf,0xd,0x4,0x1,0x2,0x5,0xb,0x8,0x6,
	0xc,0x7,0x6,0xc,0x9,0x0,0x3,0x5,0x2,0xe,0xf,0x9
},
{
	0xa,0xd,0x0,0x7,0x9,0x0,0xe,0x9,0x6,0x3,0x3,0x4,0xf,
	0x6,0x5,0xa,0x1,0x2,0xd,0x8,0xc,0x5,0x7,0xe,0xb,0xc,
	0x4,0xb,0x2,0xf,0x8,0x1,0xd,0x1,0x6,0xa,0x4,0xd,0x9,
	0x0,0x8,0x6,0xf,0x9,0x3,0x8,0x0,0x7,0xb,0x4,0x1,0xf,
	0x2,0xe,0xc,0x3,0x5,0xb,0xa,0x5,0xe,0x2,0x7,0xc
},
{
	0x7,0xd,0xd,0x8,0xe,0xb,0x3,0x5,0x0,0x6,0x6,0xf,0x9,
	0x0,0xa,0x3,0x1,0x4,0x2,0x7,0x8,0x2,0x5,0xc,0xb,0x1,
	0xc,0xa,0x4,0xe,0xf,0x9,0xa,0x3,0x6,0xf,0x9,0x0,0x0,
	0x6,0xc,0xa,0xb,0xa,0x7,0xd,0xd,0x8,0xf,0x9,0x1,0x4,
	0x3,0x5,0xe,0xb,0x5,0xc,0x2,0x7,0x8,0x2,0x4,0xe
},
{
	0x2,0xe,0xc,0xb,0x4,0x2,0x1,0xc,0x7,0x4,0xa,0x7,0xb,
	0xd,0x6,0x1,0x8,0x5,0x5,0x0,0x3,0xf,0xf,0xa,0xd,0x3,
	0x0,0x9,0xe,0x8,0x9,0x6,0x4,0xb,0x2,0x8,0x1,0xc,0xb,
	0x7,0xa,0x1,0xd,0xe,0x7,0x2,0x8,0xd,0xf,0x6,0x9,0xf,
	0xc,0x0,0x5,0x9,0x6,0xa,0x3,0x4,0x0,0x5,0xe,0x3
},
{
	0xc,0xa,0x1,0xf,0xa,0x4,0xf,0x2,0x9,0x7,0x2,0xc,0x6,
	0x9,0x8,0x5,0x0,0x6,0xd,0x1,0x3,0xd,0x4,0xe,0xe,0x0,
	0x7,0xb,0x5,0x3,0xb,0x8,0x9,0x4,0xe,0x3,0xf,0x2,0x5,
	0xc,0x2,0x9,0x8,0x5,0xc,0xf,0x3,0xa,0x7,0xb,0x0,0xe,
	0x4,0x1,0xa,0x7,0x1,0x6,0xd,0x0,0xb,0x8,0x6,0xd
},
{
	0x4,0xd,0xb,0x0,0x2,0xb,0xe,0x7,0xf,0x4,0x0,0x9,0x8,
	0x1,0xd,0xa,0x3,0xe,0xc,0x3,0x9,0x5,0x7,0xc,0x5,0x2,
	0xa,0xf,0x6,0x8,0x1,0x6,0x1,0x6,0x4,0xb,0xb,0xd,0xd,
	0x8,0xc,0x1,0x3,0x4,0x7,0xa,0xe,0x7,0xa,0x9,0xf,0x5,
	0x6,0x0,0x8,0xf,0x0,0xe,0x5,0x2,0x9,0x3,0x2,0xc
},
{
	0xd,0x1,0x2,0xf,0x8,0xd,0x4,0x8,0x6,0xa,0xf,0x3,0xb,
	0x7,0x1,0x4,0xa,0xc,0x9,0x5,0x3,0x6,0xe,0xb,0x5,0x0,
	0x0,0xe,0xc,0x9,0x7,0x2,0x7,0x2,0xb,0x1,0x4,0xe,0x1,
	0x7,0x9,0x4,0xc,0xa,0xe,0x8,0x2,0xd,0x0,0xf,0x6,0xc,
	0xa,0x9,0xd,0x0,0xf,0x3,0x3,0x5,0x5,0x6,0x8,0xb
}
};
const uint8_t DES::keyleft[28] =
{
	57,49,41,33,25,17,9,1,58,50,42,34,26,18,
	10,2,59,51,43,35,27,19,11,3,60,52,44,36
};
const uint8_t DES::keyright[28] =
{
	63,55,47,39,31,23,15,7,62,54,46,38,30,22,
	14,6,61,53,45,37,29,21,13,5,28,20,12,4
};
const uint8_t DES::lefttable[16] =
{
	1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1
};
const uint8_t DES::keychoose[48] =
{
	14,17,11,24,1,5,3,28,15,6,21,10,
	23,19,12,4,26,8,16,7,27,20,13,2,
	41,52,31,37,47,55,30,40,51,45,33,48,
	44,49,39,56,34,53,46,42,50,36,29,32
};




int32_t DES::HandleData(uint32_t * left, uint8_t choice)
{
	uint32_t *right = &left[1];
	uint32_t tmpbuf[2] = { 0 };

	int32_t number = 0, j = 0;
	uint32_t tmp = 0;

	for (j = 0; j < 64; j++) {
		if (j < 32) {
			if (ip[j] > 32) {
				if (*right&pc_by_bit[ip[j] - 1]) {
					tmpbuf[0] |= pc_by_bit[j];
				}
			}
			else {
				if (*left&pc_by_bit[ip[j] - 1]) {
					tmpbuf[0] |= pc_by_bit[j];
				}
			}
		}
		else {
			if (ip[j] > 32) {
				if (*right&pc_by_bit[ip[j] - 1]) {
					tmpbuf[1] |= pc_by_bit[j];
				}
			}
			else {
				if (*left&pc_by_bit[ip[j] - 1]) {
					tmpbuf[1] |= pc_by_bit[j];
				}
			}
		}
	}
	*left = tmpbuf[0];
	*right = tmpbuf[1];


	if (choice == DESENCRY) {
		for (int i = 0; i < 16; i++)
			MakeData(left, right, i);
	}
	else if (choice == DESDECRY) {
		for (int i = 0; i < 16; i++)
			MakeData(left, right, 15 - i);
	}


	tmpbuf[0] = 0;
	tmpbuf[1] = 0;


	for (j = 0; j < 64; j++) {
		if (j < 32) {
			if (fp[j] > 32) {
				if (*left&pc_by_bit[fp[j] - 1]) {
					tmpbuf[0] |= pc_by_bit[j];
				}
			}
			else {
				if (*right&pc_by_bit[fp[j] - 1]) {
					tmpbuf[0] |= pc_by_bit[j];
				}
			}
		}
		else {
			if (fp[j] > 32) {
				if (*left&pc_by_bit[fp[j] - 1]) {
					tmpbuf[1] |= pc_by_bit[j];
				}
			}
			else {
				if (*right&pc_by_bit[fp[j] - 1]) {
					tmpbuf[1] |= pc_by_bit[j];
				}
			}
		}
	}
	*left = tmpbuf[0];
	*right = tmpbuf[1];

	return 0;
}

int32_t DES::MakeData(uint32_t * left, uint32_t * right, uint32_t number)
{
	uint32_t oldright = *right;
	uint32_t exdes_P[2] = { 0 };
	for (int j = 0; j < 48; j++) {
		if (j < 24) {
			if (*right&pc_by_bit[des_E[j] - 1]) {
				exdes_P[0] |= pc_by_bit[j];
			}
		}
		else {
			if (*right&pc_by_bit[des_E[j] - 1]) {
				exdes_P[1] |= pc_by_bit[j - 24];
			}
		}
	}
	for (int j = 0; j < 2; j++) {
		exdes_P[j] ^= g_outkey[number][j];
	}

	uint8_t rexpbuf[8];
	exdes_P[1] >>= 8;
	rexpbuf[7] = (uint8_t)(exdes_P[1] & 0x0000003fL);
	exdes_P[1] >>= 6;
	rexpbuf[6] = (uint8_t)(exdes_P[1] & 0x0000003fL);
	exdes_P[1] >>= 6;
	rexpbuf[5] = (uint8_t)(exdes_P[1] & 0x0000003fL);
	exdes_P[1] >>= 6;
	rexpbuf[4] = (uint8_t)(exdes_P[1] & 0x0000003fL);
	exdes_P[0] >>= 8;
	rexpbuf[3] = (uint8_t)(exdes_P[0] & 0x0000003fL);
	exdes_P[0] >>= 6;
	rexpbuf[2] = (uint8_t)(exdes_P[0] & 0x0000003fL);
	exdes_P[0] >>= 6;
	rexpbuf[1] = (uint8_t)(exdes_P[0] & 0x0000003fL);
	exdes_P[0] >>= 6;
	rexpbuf[0] = (uint8_t)(exdes_P[0] & 0x0000003fL);
	exdes_P[0] = 0;
	exdes_P[1] = 0;
	*right = 0;
	for (int j = 0; j < 7; j++) {
		rexpbuf[j] |= (rexpbuf[j] & pc_by_bit[5]) << 1;
		rexpbuf[j] &= 0b1011111;
		rexpbuf[j] |= (rexpbuf[j] & pc_by_bit[0]) << 5;
		rexpbuf[j] >>= 1;
		*right |= des_S[j][rexpbuf[j]];
		*right <<= 4;
	}
	*right |= des_S[7][rexpbuf[7]];
	uint32_t datatmp = 0;
	for (int j = 0; j < 32; j++) {
		if (*right&pc_by_bit[des_P[j] - 1]) {
			datatmp |= pc_by_bit[j];
		}
	}
	*right = datatmp;
	*right ^= *left;
	*left = oldright;
	return 0;
}

int32_t DES::MakeKey(uint32_t * keyleft, uint32_t * keyright, uint32_t number)
{
	uint32_t *Poutkey = (uint32_t*)&g_outkey[number];

	*keyleft = (*keyleft << lefttable[number]) | (*keyleft >> (28 - lefttable[number]));
	*keyright = (*keyright << lefttable[number]) | (*keyright >> (28 - lefttable[number]));
	*keyleft &= 0xfffffff0;
	*keyright &= 0xfffffff0;

	for (int j = 0; j < 48; j++) {
		if (j < 24) {
			if (*keyleft&pc_by_bit[keychoose[j] - 1]) {
				Poutkey[0] |= pc_by_bit[j];
			}
		}
		else /*j>=24*/ {
			if (*keyright&pc_by_bit[(keychoose[j] - 28)]) {
				Poutkey[1] |= pc_by_bit[j - 24];
			}
		}
	}

	return 0;
}

int32_t DES::MakeFirstKey(uint32_t * keyP)
{
	uint32_t * pleft, *pright;
	pleft = &keyP[0];
	pright = &keyP[1];
	uint32_t firstkey[2] = { 0 };

	for (int i = 0; i < 28; i++) {
		if (*pleft&pc_by_bit[keyleft[i] - 1]) {
			firstkey[0] |= pc_by_bit[i];
		}
		if (*pright&pc_by_bit[keyright[i] - 1]) {
			firstkey[1] |= pc_by_bit[i];
		}
	}

	for (int i = 0; i < 16; i++) {
		MakeKey(&firstkey[0], &firstkey[1], i);
	}


	return 0;
}

DES::DES()
{

}

DES::~DES()
{
}

int32_t DES::Encry(char * pPlaintext, int nPlaintextLength, char * pCipherBuffer, int & nCipherBufferLength, char * pKey, int nKeyLength)
{
	if (nKeyLength != 8) {
		return 0;
	}

	memset(g_outkey, 0, sizeof(uint32_t) * 32);
	memset(m_arrBufKey, 0, sizeof(uint32_t) * 2);

	MakeFirstKey((uint32_t *)pKey);
	int nLenthof32Bits = ((nPlaintextLength + 7) / 8) * 2;
	if (nCipherBufferLength < nLenthof32Bits * 4) {
		//out put buffer is not enough
		nCipherBufferLength = nLenthof32Bits * 4;
		return 0;
	}
	memset(pCipherBuffer, 0, nCipherBufferLength);
	uint32_t *pOutPutSpace = (uint32_t *)pCipherBuffer;
	uint32_t * pSource;
	if (nPlaintextLength != sizeof(uint32_t)*nLenthof32Bits) {
		pSource = new uint32_t[nLenthof32Bits];
		memset(pSource, 0, sizeof(uint32_t)*nLenthof32Bits);
		memcpy(pSource, pPlaintext, nPlaintextLength);
	}
	else {
		pSource = (uint32_t *)pPlaintext;
	}

	uint32_t gp_msg[2] = { 0,0 };

	for (int i = 0; i < (nLenthof32Bits / 2); i++) {
		gp_msg[0] = pSource[2 * i];
		gp_msg[1] = pSource[2 * i + 1];
		HandleData(gp_msg, DESENCRY);
		pOutPutSpace[2 * i] = gp_msg[0];
		pOutPutSpace[2 * i + 1] = gp_msg[1];
	}
	if (pPlaintext != (char *)pSource) {
		delete[]pSource;
	}
	return 0;
}

int32_t DES::Decry(char * pCipher, int nCipherBufferLength, char * pPlaintextBuffer, int & nPlaintextBufferLength, char * pKey, int nKeyLength)
{
	if (nKeyLength != 8) {
		return 0;
	}

	memset(g_outkey, 0, sizeof(uint32_t) * 32);
	memset(m_arrBufKey, 0, sizeof(uint32_t) * 2);

	MakeFirstKey((uint32_t *)pKey);
	int nLenthof32Bits = ((nCipherBufferLength + 7) / 8) * 2;
	if (nPlaintextBufferLength < nLenthof32Bits * 4) {
		//out put buffer is not enough
		nPlaintextBufferLength = nLenthof32Bits * 4;
		return 0;
	}
	memset(pPlaintextBuffer, 0, nPlaintextBufferLength);
	uint32_t *pOutPutSpace = (uint32_t *)pPlaintextBuffer;
	uint32_t * pSource;
	if (nCipherBufferLength != sizeof(uint32_t)*nLenthof32Bits) {
		pSource = new uint32_t[nLenthof32Bits];
		memset(pSource, 0, sizeof(uint32_t)*nLenthof32Bits);
		memcpy(pSource, pCipher, nCipherBufferLength);
	}
	else {
		pSource = (uint32_t *)pCipher;
	}

	uint32_t gp_msg[2] = { 0,0 };

	for (int i = 0; i < (nLenthof32Bits / 2); i++) {
		gp_msg[0] = pSource[2 * i];
		gp_msg[1] = pSource[2 * i + 1];
		HandleData(gp_msg, DESDECRY);
		pOutPutSpace[2 * i] = gp_msg[0];
		pOutPutSpace[2 * i + 1] = gp_msg[1];
	}
	if (pCipher != (char *)pSource) {
		delete[]pSource;
	}
	return 0;
}
